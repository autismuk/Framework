<!DOCTYPE html><html><head><style>body { background:#333; color:#0F0; font-family:Arial,Verdana;} a { color:#0AA } h1 { color:#FF0; } h2 { color:#0FF } table,tr,td { color: #CCC; padding:4px;border:1px solid white; border-collapse:collapse; }</style></head><body>
<a name="ads.admob"></a>
<hr><h1>ads.admob</h1>
<p><h3>Extends </h3></p>
<p>Advert object. admob for iOS and Android, provides a fake if running in simulator.</p>
<p>Methods : <a href="#Advert_constructor"/>constructor</a>,<a href="#Advert_destructor"/>destructor</a>,<a href="#Advert_getDisplayObjects"/>getDisplayObjects</a>,<a href="#Advert_getHeight"/>getHeight</a>,<a href="#Advert_onTimer"/>onTimer</a></p><hr><a name="Advert_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Constructor information.</td></tr>
</table>
<p>Create an advert. Parameters passed are android/ios/universal (Admob AppIDs), advertType, defaults to banner. Must provide the admob app-IDs</p>
<a name="Advert_destructor"></a>
<h2>destructor()</h2>
<p>Tidy up.</p>
<a name="Advert_getDisplayObjects"></a>
<h2>getDisplayObjects()</h2>
<p></p>
<a name="Advert_getHeight"></a>
<h2>getHeight()</h2>
<table>
<tr><td>return</td><td>number</td><td>height.</td></tr>
</table>
<p>Gets the height of the banner in Corona device units. This function can only be called once the first advert is created, due to a limitation in Corona. Therefore if you must know the height of a banner, you will have to create one and destroy one.</p>
<a name="Advert_onTimer"></a>
<h2>onTimer(tag,timerID)</h2>
<table>
<tr><td>tag</td><td></td><td></td></tr>
<tr><td>timerID</td><td></td><td></td></tr>
</table>
<p>This fakes the 'late' arrival of the actual advert, rather than it being put up straight away.</p>
<a name="audio.music"></a>
<hr><h1>audio.music</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#BackgroundMusicPlayer_constructor"/>constructor</a>,<a href="#BackgroundMusicPlayer_destructor"/>destructor</a>,<a href="#BackgroundMusicPlayer_onMessage"/>onMessage</a></p><hr><a name="BackgroundMusicPlayer_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td></td><td></td></tr>
</table>
<p>Constructor. info contains a music entry (defaults to music.mp3) which is in the audio directory, a fadeIn time (defaults to 2s) and a fadeOut time (defaults to fadeIn time)</p>
<a name="BackgroundMusicPlayer_destructor"></a>
<h2>destructor()</h2>
<p>Destructor</p>
<a name="BackgroundMusicPlayer_onMessage"></a>
<h2>onMessage(sender,name,body)</h2>
<table>
<tr><td>sender</td><td></td><td></td></tr>
<tr><td>name</td><td></td><td></td></tr>
<tr><td>body</td><td></td><td></td></tr>
</table>
<p></p>
<a name="audio.sound"></a>
<hr><h1>audio.sound</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#AudioCache_constructor"/>constructor</a>,<a href="#AudioCache_destructor"/>destructor</a>,<a href="#AudioCache_getFileName"/>getFileName</a>,<a href="#AudioCache_isSoundPresent"/>isSoundPresent</a>,<a href="#AudioCache_onMessage"/>onMessage</a>,<a href="#AudioCache_play"/>play</a></p><hr><a name="AudioCache_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Constructor parameters</td></tr>
</table>
<p>Constructor - info.sounds is a list of samples, default is mp3.</p>
<a name="AudioCache_destructor"></a>
<h2>destructor()</h2>
<p>Destructor</p>
<a name="AudioCache_getFileName"></a>
<h2>getFileName(name)</h2>
<table>
<tr><td>name</td><td>string</td><td>short file name</td></tr>
<tr><td>return</td><td>string</td><td>reference to file, in audio subdirectory.</td></tr>
</table>
<p>Given a stub file, get the full file name</p>
<a name="AudioCache_isSoundPresent"></a>
<h2>isSoundPresent(name)</h2>
<table>
<tr><td>name</td><td>string</td><td>short name of sound</td></tr>
<tr><td>return</td><td>boolean</td><td>true if present.</td></tr>
</table>
<p>Check if sound present.</p>
<a name="AudioCache_onMessage"></a>
<h2>onMessage(sender,name,body)</h2>
<table>
<tr><td>sender</td><td>object</td><td>Who sent the message</td></tr>
<tr><td>name</td><td>string</td><td>Should be 'play'</td></tr>
<tr><td>body</td><td>table</td><td>sound and options members for the play call</td></tr>
</table>
<p>Handle the message which instructs a sfx to play.</p>
<a name="AudioCache_play"></a>
<h2>play(name,options)</h2>
<table>
<tr><td>name</td><td>string</td><td>stub name, case insensitive</td></tr>
<tr><td>options</td><td>table</td><td>options for play, see audio.play() documents</td></tr>
</table>
<p>Play a sound effect from the cache.</p>
<a name="game.manager"></a>
<hr><h1>game.manager</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#GameManager_addManagedState"/>addManagedState</a>,<a href="#GameManager_assignManager"/>assignManager</a>,<a href="#GameManager_constructor"/>constructor</a>,<a href="#GameManager_destructor"/>destructor</a>,<a href="#GameManager_endSceneTransition"/>endSceneTransition</a>,<a href="#GameManager_onMessage"/>onMessage</a>,<a href="#GameManager_start"/>start</a>,<a href="#GameManager_startSceneTransition"/>startSceneTransition</a></p><hr><a name="GameManager_addManagedState"></a>
<h2>addManagedState(stateName,sceneManagerInstance,eventTarget)</h2>
<table>
<tr><td>stateName</td><td>string</td><td>name of state</td></tr>
<tr><td>sceneManagerInstance</td><td>object</td><td>sceneManager associated with scene</td></tr>
<tr><td>eventTarget</td><td>table</td><td>events and targets, see system.fsm</td></tr>
</table>
<p>Add a state, a sceneManager instance and a series of events and targets - helper function.</p>
<a name="GameManager_assignManager"></a>
<h2>assignManager(stateName,sceneManagerInstance)</h2>
<table>
<tr><td>stateName</td><td>string</td><td>name of state</td></tr>
<tr><td>sceneManagerInstance</td><td>object</td><td>sceneManager associated with scene</td></tr>
</table>
<p>Assign a scene manager instance to a specific state.</p>
<a name="GameManager_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>constructor information.</td></tr>
</table>
<p>Construct a game manager object</p>
<a name="GameManager_destructor"></a>
<h2>destructor()</h2>
<p>Tidy up</p>
<a name="GameManager_endSceneTransition"></a>
<h2>endSceneTransition()</h2>
<p>Complete the transition practicalities after the visual transition has been done this method is called by the transitioner, see above.</p>
<a name="GameManager_onMessage"></a>
<h2>onMessage(sender,name,body)</h2>
<table>
<tr><td>sender</td><td>object</td><td>controller object</td></tr>
<tr><td>name</td><td>string</td><td>name of message</td></tr>
<tr><td>body</td><td></td><td></td></tr>
</table>
<p>Handle message. These are sent by the controller object. While the transition is in progress the messaging, timers, updates are off</p>
<a name="GameManager_start"></a>
<h2>start(startState)</h2>
<table>
<tr><td>startState</td><td>string</td><td>First scene, defaults to 'start'</td></tr>
</table>
<p>Start the game manager, go to first scene</p>
<a name="GameManager_startSceneTransition"></a>
<h2>startSceneTransition(newState,transitionType,transitionTime)</h2>
<table>
<tr><td>newState</td><td>string</td><td>state to go to</td></tr>
<tr><td>transitionType</td><td>string</td><td>transition type</td></tr>
<tr><td>transitionTime</td><td>number</td><td>transition time in seconds</td></tr>
</table>
<p>Start a transition to a new state</p>
<a name="game.scene"></a>
<hr><h1>game.scene</h1>
<p><h3>Extends system.collection</h3></p>
<p></p>
<p>Methods : <a href="#Scene_constructor"/>constructor</a>,<a href="#Scene_destructor"/>destructor</a>,<a href="#Scene_getContainer"/>getContainer</a>,<a href="#Scene_new"/>new</a>,<a href="#Scene_onEnterFrame"/>onEnterFrame</a></p><hr><a name="Scene_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Initialisation info (ignored)</td></tr>
</table>
<p>Construct a scene, which is a collection with updating and a possible global container.</p>
<a name="Scene_destructor"></a>
<h2>destructor()</h2>
<p>Delete collection ; deletes objects in the collection too.</p>
<a name="Scene_getContainer"></a>
<h2>getContainer()</h2>
<table>
<tr><td>return</td><td>container</td><td>Corona container clipped to display limits.</td></tr>
</table>
<p>Get the container, creating it if necessary.</p>
<a name="Scene_new"></a>
<h2>new(className,data)</h2>
<table>
<tr><td>className</td><td>string/object</td><td>Name of class to create instance of or prototype object.</td></tr>
<tr><td>data</td><td>table</td><td>Optional instantiation data (is passed to constructor as {} if nil)</td></tr>
</table>
<p>Create a new object, add to the collection, and check for a getDisplayObjects() method.</p>
<a name="Scene_onEnterFrame"></a>
<h2>onEnterFrame(deltaTime)</h2>
<table>
<tr><td>deltaTime</td><td>number</td><td>elapsed time in seconds</td></tr>
</table>
<p>Handle enterFrame message, dispatch to all collection objects which implement onUpdate()</p>
<a name="game.scenemanager"></a>
<hr><h1>game.scenemanager</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#SceneManager_constructor"/>constructor</a>,<a href="#SceneManager_destructor"/>destructor</a>,<a href="#SceneManager_getScene"/>getScene</a>,<a href="#SceneManager_postClose"/>postClose</a>,<a href="#SceneManager_postOpen"/>postOpen</a>,<a href="#SceneManager_preClose"/>preClose</a>,<a href="#SceneManager_preOpen"/>preOpen</a>,<a href="#SceneManager_resourceConstructor"/>resourceConstructor</a>,<a href="#SceneManager_resourceDestructor"/>resourceDestructor</a>,<a href="#SceneManager_setEventData"/>setEventData</a></p><hr><a name="SceneManager_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Unused</td></tr>
</table>
<p>Create a new Game Scene Manager</p>
<a name="SceneManager_destructor"></a>
<h2>destructor()</h2>
<p>Tidy up.</p>
<a name="SceneManager_doPostClose"></a>
<a name="SceneManager_doPostOpen"></a>
<a name="SceneManager_doPreClose"></a>
<a name="SceneManager_doPreOpen"></a>
<a name="SceneManager_getScene"></a>
<h2>getScene()</h2>
<table>
<tr><td>return</td><td>object</td><td>Scene object</td></tr>
</table>
<p>Get the scene associated with the scene manager instance</p>
<a name="SceneManager_postClose"></a>
<h2>postClose(scene,manager,data,resources)</h2>
<table>
<tr><td>scene</td><td>object</td><td>game.scene object being worked on</td></tr>
<tr><td>manager</td><td>object</td><td>manager controlling it.</td></tr>
<tr><td>data</td><td>table</td><td>control data passed by event</td></tr>
<tr><td>resources</td><td>table</td><td>Resource table</td></tr>
</table>
<p>Handler for postClose event, called when scene transitioned off and about to be deleted.</p>
<a name="SceneManager_postOpen"></a>
<h2>postOpen(scene,manager,data,resources)</h2>
<table>
<tr><td>scene</td><td>object</td><td>game.scene object being worked on</td></tr>
<tr><td>manager</td><td>object</td><td>manager controlling it.</td></tr>
<tr><td>data</td><td>table</td><td>control data passed by event</td></tr>
<tr><td>resources</td><td>table</td><td>Resource table</td></tr>
</table>
<p>Handler for preOpen event, called when scene displayed on stage but has not been started</p>
<a name="SceneManager_preClose"></a>
<h2>preClose(scene,manager,data,resources)</h2>
<table>
<tr><td>scene</td><td>object</td><td>game.scene object being worked on</td></tr>
<tr><td>manager</td><td>object</td><td>manager controlling it.</td></tr>
<tr><td>data</td><td>table</td><td>control data passed by event</td></tr>
<tr><td>resources</td><td>table</td><td>Resource table</td></tr>
</table>
<p>Handler for preClose event, called when scene has been exited but it is still visible, about to be transitioned off.</p>
<a name="SceneManager_preOpen"></a>
<h2>preOpen(manager,data,resources)</h2>
<table>
<tr><td>manager</td><td>object</td><td>manager controlling it.</td></tr>
<tr><td>data</td><td>table</td><td>control data passed by event</td></tr>
<tr><td>resources</td><td>table</td><td>Resource table</td></tr>
<tr><td>return</td><td>object</td><td>game.scene object</td></tr>
</table>
<p>Handler for preOpen event, creates a new scene, before starting to transition it on.</p>
<a name="SceneManager_resourceConstructor"></a>
<h2>resourceConstructor(rt)</h2>
<table>
<tr><td>rt</td><td>table</td><td>Resource table</td></tr>
</table>
<p>Create/Load resources</p>
<a name="SceneManager_resourceDestructor"></a>
<h2>resourceDestructor(rt)</h2>
<table>
<tr><td>rt</td><td>table</td><td>Resource table</td></tr>
</table>
<p>Free/Tidy up resources</p>
<a name="SceneManager_setEventData"></a>
<h2>setEventData(data)</h2>
<table>
<tr><td>data</td><td>table</td><td>event provided data.</td></tr>
</table>
<p>Set the associated event data, combined with the info table passed into the constructor</p>
<a name="io.controller.fouraxis"></a>
<hr><h1>io.controller.fouraxis</h1>
<p><h3>Extends </h3></p>
<p>Four way controller class</p>
<p>Methods : <a href="#Controller_constructor"/>constructor</a>,<a href="#Controller_destructor"/>destructor</a>,<a href="#Controller_getDisplayObjects"/>getDisplayObjects</a>,<a href="#Controller_getX"/>getX</a>,<a href="#Controller_getY"/>getY</a></p><hr><a name="Controller_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>contains (optionally x,y and radius)</td></tr>
</table>
<p>Create a new controller.</p>
<a name="Controller_createDisplay"></a>
<a name="Controller_destructor"></a>
<h2>destructor()</h2>
<p>Remove a controller.</p>
<a name="Controller_getDisplayObjects"></a>
<h2>getDisplayObjects()</h2>
<table>
<tr><td>return</td><td>list</td><td>List of display objects</td></tr>
</table>
<p>Get display objects for Scenes</p>
<a name="Controller_getX"></a>
<h2>getX()</h2>
<table>
<tr><td>return</td><td>number</td><td>value from -1 to 1</td></tr>
</table>
<p>Get current stick position horizontal</p>
<a name="Controller_getY"></a>
<h2>getY()</h2>
<table>
<tr><td>return</td><td>number</td><td>value from -1 to 1</td></tr>
</table>
<p>Get current stick position vertical</p>
<a name="Controller_minimax"></a>
<a name="Controller_touch"></a>
<a name="system.collection"></a>
<hr><h1>system.collection</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#Collection_constructor"/>constructor</a>,<a href="#Collection_destructor"/>destructor</a>,<a href="#Collection_getCollection"/>getCollection</a>,<a href="#Collection_makeTag"/>makeTag</a>,<a href="#Collection_new"/>new</a></p><hr><a name="Collection_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Initialisation info (ignored)</td></tr>
</table>
<p>Construct a collection of objects</p>
<a name="Collection_destructor"></a>
<h2>destructor()</h2>
<p>Delete collection ; deletes objects in the collection too.</p>
<a name="Collection_getCollection"></a>
<h2>getCollection()</h2>
<table>
<tr><td>return</td><td>number,table</td><td>Two elements, number of items and hash of items</td></tr>
</table>
<p>Get all objects in the collection</p>
<a name="Collection_makeTag"></a>
<h2>makeTag(base)</h2>
<table>
<tr><td>base</td><td>string</td><td>tag to use to make a unique one.</td></tr>
<tr><td>return</td><td>string</td><td>tag unique to this</td></tr>
</table>
<p>Create a unique tag for this collection, useful for multiple instances.</p>
<a name="Collection_new"></a>
<h2>new(className,data)</h2>
<table>
<tr><td>className</td><td>string/object</td><td>Name of class to create instance of or prototype object.</td></tr>
<tr><td>data</td><td>table</td><td>Optional instantiation data (is passed to constructor as {} if nil)</td></tr>
</table>
<p>Create a new object and attach it to this collection using a tag.</p>
<a name="system.framework"></a>
<hr><h1>system.framework</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#Framework_addObjectMethod"/>addObjectMethod</a>,<a href="#Framework_convert"/>convert</a>,<a href="#Framework_createClass"/>createClass</a>,<a href="#Framework_delete"/>delete</a>,<a href="#Framework_enterFrame"/>enterFrame</a>,<a href="#Framework_name"/>name</a>,<a href="#Framework_new"/>new</a>,<a href="#Framework_perform"/>perform</a>,<a href="#Framework_query"/>query</a>,<a href="#Framework_register"/>register</a>,<a href="#Framework_setEnterFrameEnabled"/>setEnterFrameEnabled</a>,<a href="#Framework_split"/>split</a>,<a href="#Framework_tag"/>tag</a>,<a href="#Framework_validateClassIdentifier"/>validateClassIdentifier</a>,<a href="#Framework_validateLuaIdentifier"/>validateLuaIdentifier</a></p><hr><a name="Framework_addObjectMethod"></a>
<h2>addObjectMethod(methodName,methodEntity)</h2>
<table>
<tr><td>methodName</td><td>string</td><td>Name of method</td></tr>
<tr><td>methodEntity</td><td>anything</td><td>Whatever you want to add, normally a function.</td></tr>
</table>
<p>Add a method to the object method structure</p>
<a name="Framework_convert"></a>
<h2>convert(object,data)</h2>
<table>
<tr><td>object</td><td>table</td><td>Object to be converted. Can come from framework or could be a Corona object, say.</td></tr>
<tr><td>data</td><td>table</td><td>Optional instantiation data (is passed to constructor as {} if nil)</td></tr>
</table>
<p>Convert a lua object into one useable by the framework and store it in the framework. After validation, add the default __frameworkData storage element, add in the mixins, tag it as "frameworkObject", and call the constructor</p>
<a name="Framework_createClass"></a>
<h2>createClass(className,superClass)</h2>
<table>
<tr><td>className</td><td>string</td><td>Class identifier.</td></tr>
<tr><td>superClass</td><td>string/table</td><td>Superclass, may be nil.</td></tr>
</table>
<p>Create and register a new class, which may be subclassed from another class.</p>
<a name="Framework_delete"></a>
<h2>delete(object)</h2>
<table>
<tr><td>object</td><td>object</td><td>Object you want to delete.</td></tr>
</table>
<p>Delete an object, calling the destructor, then fixing up the indexes so they do not contain this object any more.</p>
<a name="Framework_enterFrame"></a>
<h2>enterFrame(event)</h2>
<table>
<tr><td>event</td><td>table</td><td>Event data.</td></tr>
</table>
<p>Handle enterFrame event. If there are any objects tagged enterFrame call their onEnterFrame() method.</p>
<a name="Framework_name"></a>
<h2>name(object,name)</h2>
<table>
<tr><td>object</td><td>table</td><td>object to name</td></tr>
<tr><td>name</td><td>string</td><td>name to give object.</td></tr>
</table>
<p>Name an object</p>
<a name="Framework_new"></a>
<h2>new(className,data)</h2>
<table>
<tr><td>className</td><td>string/object</td><td>Name of class to create instance of or prototype object.</td></tr>
<tr><td>data</td><td>table</td><td>Optional instantiation data (is passed to constructor as {} if nil)</td></tr>
</table>
<p>Create a new object, given a class name or prototype, and optional initialisation data. Create the object, then set it up (add framework stuff, and call constructor)</p>
<a name="Framework_perform"></a>
<h2>perform(objectTable,method,p1,p2,p3)</h2>
<table>
<tr><td>objectTable</td><td>table</td><td>table of objects (use value, non consecutive)</td></tr>
<tr><td>method</td><td>string</td><td>method name.</td></tr>
<tr><td>p1</td><td>anything</td><td>parameter</td></tr>
<tr><td>p2</td><td>anything</td><td>parameter</td></tr>
<tr><td>p3</td><td>anything</td><td>parameter</td></tr>
</table>
<p>Perform a method call on a table of objects.</p>
<a name="Framework_query"></a>
<h2>query(queryString)</h2>
<table>
<tr><td>queryString</td><td>string</td><td>Comma seperated list of tags (defaults to "", which is the frameworkObject tag)</td></tr>
<tr><td>return</td><td>number,table</td><td>Two elements, number of items and hash of items</td></tr>
</table>
<p>Query the Framework object database for all objects with all the named tags.</p>
<a name="Framework_register"></a>
<h2>register(className,classPrototype)</h2>
<table>
<tr><td>className</td><td>string</td><td>Class identifier.</td></tr>
<tr><td>classPrototype</td><td>table</td><td>Class prototype.</td></tr>
</table>
<p>Register a new class in the class list.</p>
<a name="Framework_setEnterFrameEnabled"></a>
<h2>setEnterFrameEnabled(isEnabled)</h2>
<table>
<tr><td>isEnabled</td><td>boolean</td><td>true to enable, false to disable</td></tr>
</table>
<p>Enable or disable the enterFrame event.</p>
<a name="Framework_split"></a>
<h2>split(string,split)</h2>
<table>
<tr><td>string</td><td>string</td><td>String to split</td></tr>
<tr><td>split</td><td>string</td><td>Characters to split over.</td></tr>
<tr><td>return</td><td>list</td><td>List of strings.</td></tr>
</table>
<p>Convert a string to an array of strings, using the given separator</p>
<a name="Framework_tag"></a>
<h2>tag(object,tagName,command)</h2>
<table>
<tr><td>object</td><td>table</td><td>Object to tag/detag</td></tr>
<tr><td>tagName</td><td>string</td><td>tag to apply/remove</td></tr>
<tr><td>command</td><td>number</td><td>Command to do with tag.</td></tr>
</table>
<p>Add or remove a tag from an object, updating the tag indices as you go.</p>
<a name="Framework_validateClassIdentifier"></a>
<h2>validateClassIdentifier(identifier)</h2>
<table>
<tr><td>identifier</td><td>string</td><td>string to validate</td></tr>
<tr><td>return</td><td>boolean</td><td>true if valid.</td></tr>
</table>
<p>Validate a class identifier. It should be a sequence of alphanumeric words, beginning with a letter, seperated by full stops.</p>
<a name="Framework_validateLuaIdentifier"></a>
<h2>validateLuaIdentifier(identifier)</h2>
<table>
<tr><td>identifier</td><td>string</td><td>string to validate</td></tr>
<tr><td>return</td><td>boolean</td><td>true if valid.</td></tr>
</table>
<p>Validate a lua identifier. This is defined as a alphabetic character followed by a number alphanumeric characters, this number may be zero.</p>
<a name="system.fsm"></a>
<hr><h1>system.fsm</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#FSMachine_addState"/>addState</a>,<a href="#FSMachine_constructor"/>constructor</a>,<a href="#FSMachine_destructor"/>destructor</a>,<a href="#FSMachine_event"/>event</a>,<a href="#FSMachine_setBroadcastTag"/>setBroadcastTag</a>,<a href="#FSMachine_start"/>start</a></p><hr><a name="FSMachine_addState"></a>
<h2>addState(stateName,eventTable)</h2>
<table>
<tr><td>stateName</td><td>string</td><td>new state name</td></tr>
<tr><td>eventTable</td><td>table</td><td>pairs of event / new state</td></tr>
<tr><td>return</td><td>object</td><td>self,chainable</td></tr>
</table>
<p>Add a state and its event/new state pairs.</p>
<a name="FSMachine_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>Unused</td></tr>
</table>
<p>Create a new FSM</p>
<a name="FSMachine_destructor"></a>
<h2>destructor()</h2>
<p>Tidy up.</p>
<a name="FSMachine_event"></a>
<h2>event(event)</h2>
<table>
<tr><td>event</td><td>string</td><td>FSM event to cause a state transition.</td></tr>
</table>
<p>Process an FSM event - find the new state and send the asynchronous messages.</p>
<a name="FSMachine_setBroadcastTag"></a>
<h2>setBroadcastTag(tagName)</h2>
<table>
<tr><td>tagName</td><td>string</td><td>New broadcast tag, defaults to fsmListener</td></tr>
<tr><td>return</td><td>object</td><td>self,chainable</td></tr>
</table>
<p>Set broadcast tag</p>
<a name="FSMachine_start"></a>
<h2>start(startState)</h2>
<table>
<tr><td>startState</td><td>string</td><td>State to start from, defaults to 'start'.</td></tr>
</table>
<p>Start the FSM</p>
<a name="system.messaging"></a>
<hr><h1>system.messaging</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#MessagingClass_constructor"/>constructor</a>,<a href="#MessagingClass_destructor"/>destructor</a>,<a href="#MessagingClass_onEnterFrame"/>onEnterFrame</a>,<a href="#MessagingClass_sendMessage"/>sendMessage</a>,<a href="#MessagingClass_sendSingleMessage"/>sendSingleMessage</a></p><hr><a name="MessagingClass_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td></td><td></td></tr>
</table>
<p>Construct the messaging object.</p>
<a name="MessagingClass_destructor"></a>
<h2>destructor()</h2>
<p>Destroy the messaging object.</p>
<a name="MessagingClass_onEnterFrame"></a>
<h2>onEnterFrame(deltaTime)</h2>
<table>
<tr><td>deltaTime</td><td>number</td><td>elapsed time in seconds</td></tr>
</table>
<p>Called every frame. Dispatches messages that are due.</p>
<a name="MessagingClass_sendMessage"></a>
<h2>sendMessage(target,name,body,delay)</h2>
<table>
<tr><td>target</td><td>string/object</td><td>query or recipient, can be a single entity or a hash of them.</td></tr>
<tr><td>name</td><td>string</td><td>message name. (optional)</td></tr>
<tr><td>body</td><td>table</td><td>anything else you want to send other than the name  (optional)</td></tr>
<tr><td>delay</td><td>number</td><td>delay sending the message this many seconds.</td></tr>
</table>
<p>Send a message via the queue.</p>
<a name="MessagingClass_sendSingleMessage"></a>
<h2>sendSingleMessage(message)</h2>
<table>
<tr><td>message</td><td>table</td><td>message structure.</td></tr>
</table>
<p>Send a single message</p>
<a name="system.timer"></a>
<hr><h1>system.timer</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#TimerClass_cancelTimer"/>cancelTimer</a>,<a href="#TimerClass_constructor"/>constructor</a>,<a href="#TimerClass_destructor"/>destructor</a>,<a href="#TimerClass_onEnterFrame"/>onEnterFrame</a>,<a href="#TimerClass_sortTimerList"/>sortTimerList</a></p><hr><a name="TimerClass_cancelTimer"></a>
<h2>cancelTimer(target,tag)</h2>
<table>
<tr><td>target</td><td>object</td><td>who the timer event is for</td></tr>
<tr><td>tag</td><td>string</td><td>timer identification tag (not optional)</td></tr>
</table>
<p>Cancel a timer, using the tag to identify it.</p>
<a name="TimerClass_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td></td><td></td></tr>
</table>
<p>Construct the timer object.</p>
<a name="TimerClass_destructor"></a>
<h2>destructor()</h2>
<p>Destroy the timer object.</p>
<a name="TimerClass_onEnterFrame"></a>
<h2>onEnterFrame(deltaTime)</h2>
<table>
<tr><td>deltaTime</td><td>number</td><td>elapsed time in seconds</td></tr>
</table>
<p>Called every frame. Dispatches messages that are due.</p>
<a name="TimerClass_sortTimerList"></a>
<h2>sortTimerList()</h2>
<p>Add a new timer event Sort the timer items so the next triggered ones (e.g. earliest fire time) are up front.</p>
<a name="system.transition"></a>
<hr><h1>system.transition</h1>
<p><h3>Extends </h3></p>
<p></p>
<p>Methods : <a href="#Transitioner_constructor"/>constructor</a>,<a href="#Transitioner_define"/>define</a>,<a href="#Transitioner_destructor"/>destructor</a>,<a href="#Transitioner_execute"/>execute</a>,<a href="#Transitioner_executePhase"/>executePhase</a>,<a href="#Transitioner_exitTransition"/>exitTransition</a>,<a href="#Transitioner_resetScene"/>resetScene</a>,<a href="#Transitioner_setupStandardTransitions"/>setupStandardTransitions</a>,<a href="#Transitioner_setupTransform"/>setupTransform</a></p><hr><a name="Transitioner_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td></td><td></td></tr>
</table>
<p>Constructor</p>
<a name="Transitioner_define"></a>
<h2>define(name,fromTransition,toTransition,options)</h2>
<table>
<tr><td>name</td><td></td><td></td></tr>
<tr><td>fromTransition</td><td></td><td></td></tr>
<tr><td>toTransition</td><td></td><td></td></tr>
<tr><td>options</td><td></td><td></td></tr>
</table>
<p>Support function for transition creations. It's purpose is to get the transition date (below) into the m_transitionLibrary table.</p>
<a name="Transitioner_destructor"></a>
<h2>destructor()</h2>
<p>Destructor</p>
<a name="Transitioner_execute"></a>
<h2>execute(display1,display2,transitionType,transitionTime,notifier,notifyMethod)</h2>
<table>
<tr><td>display1</td><td>container/group</td><td>scene to transition out (may be nil)</td></tr>
<tr><td>display2</td><td>continaer/group</td><td>scene to transition in</td></tr>
<tr><td>transitionType</td><td>string</td><td>transition name</td></tr>
<tr><td>transitionTime</td><td>number</td><td>time in seconds</td></tr>
<tr><td>notifier</td><td>object</td><td>object to notify when complete</td></tr>
<tr><td>notifyMethod</td><td>string</td><td>method in that object to call.</td></tr>
</table>
<p>Run a transition. This consiss of two parts ; phase 1, which transitions the old scene off, phase 2 which transitions the new scene on (and the old scene off if it is concurrent)</p>
<a name="Transitioner_executePhase"></a>
<h2>executePhase()</h2>
<p>Execute the next phase of the transition - 1 = phase out first (not concurrent), 2 phase in second (phase out first if concurrent) 3 notify we have finished.</p>
<a name="Transitioner_exitTransition"></a>
<h2>exitTransition()</h2>
<p>Transition is complete - tidy everything up and reset things back for continuation, notify the listener we've done, and null all references.</p>
<a name="Transitioner_resetScene"></a>
<h2>resetScene(display)</h2>
<table>
<tr><td>display</td><td>container/group</td><td>thing to reset.</td></tr>
</table>
<p>Reset a scene back to the default state.</p>
<a name="Transitioner_setupStandardTransitions"></a>
<h2>setupStandardTransitions()</h2>
<p>Create the table of standard transitions</p>
<a name="Transitioner_setupTransform"></a>
<h2>setupTransform(displayObject,transformDefinition,executeOnCompletion)</h2>
<table>
<tr><td>displayObject</td><td>displayObject</td><td>Object to transform</td></tr>
<tr><td>transformDefinition</td><td>transform</td><td>Transform definition (collection of xEnd/yEnd/xStart etc.)</td></tr>
<tr><td>executeOnCompletion</td><td>boolean</td><td>If true, then when the transform is finished, call executePhase() to do the next phase.</td></tr>
</table>
<p>Start a transform on the given display object, optionally running executePhase() when done.</p>
<hr><p><i>LUA Autodoc by Paul Robson 2014</i></p><hr></body></html>
